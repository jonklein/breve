@use Push.
@use Control.
@use NetworkServer.

Object : PushGP {
	% This class is a special control class used to implement 
	% experiments using the Push Genetic Programming (PushGP)
	% system.  PushGP is a system which uses genetic programming
	% and the Push programming language to attempt to evolve 
	% solutions to a wide variety of problems.  For more 
	% information on Push and PushGP, see the class OBJECT(PushInterpreter).
	% <p>
	% This class is appropriate for evolving Push programs which
	% are only run once per fitness case.
	% <p>
	% To implement a PushGP experiment you will need to setup
	% a PushGP object which overrides two methods:
	% METHOD(setup-fitness-test), which sets up a fitness test
	% and METHOD(compute-error), which is used to compute the 
	% fitness of an individual.
	% <p>
	% Additionally, other methods in this class are useful for
	% configuring the genetic programming environment and a 
	% variety of parameters including population size, 
	% mutation rate, crossover rate, and the Push language 	
	% interpreter set.
	% <p>
	% Finally, you may also wish to add custom instructions 
	% to the Push interpreter objects which manipulate data
	% or trigger actions in the simulated world.  The Push
	% interpreter can be retrieved using the method 
	% METHOD(get-interpreter), and adding instructions is 
	% documented in OBJECT(PushInterpreter).

	+ variables:
		interpreter (object).
		pop1, pop2 (list).
		current, next (list).
		_abortFitnessTest (int).
		_abortFitnessValue (float).

		_bestOfGen (object).
		_totalSize (int).
		_totalErrors (double).

		_solutionCountsGeneration (list).
		_solutionCountsTotal (list).

		_solutionRatesGeneration (list).
		_solutionRatesTotal (list).

		_useChallenges (int).

		generation (int).

		inited (int).

		crossoverPercent, mutationPercent, deletionPercent (float).
		tournamentSize (int).
		populationSize (int).
		currentIndividual, currentFitnessTest (int).
		generationLimit (int).

		fitnessTestDuration (float).

		spatialRadius (int).

		seed (string).

  + section "Setting and Retrieving GP Parameters"

	+ to seed-population with-program pushProgram (object):
		% Uses pushProgram to seed the initial population.
		seed = (pushProgram get-string).

	+ to set-generation-limit to n (int):
		% Sets the generation limit to n.  If no solution is found by
		% the generation limit, the simulation with terminate.  The 
		% default value is 300.
		generationLimit = n.

	+ to get-generation-limit:
		% Returns the generation limit.  See METHOD(set-generation-limit)
		% for more information.
		return generationLimit.

	+ to set-tournament-size to n (int):
		% Sets the tournament size to n.  The tournament size determines 
		% how many individuals are examined during tournament selection.
		% The default value is 7.
		tournamentSize = n.

	+ to get-tournament-size: 
		% Returns the tournament size.  See METHOD(set-tournament-size)
		% for more information.
		return tournamentSize.

	+ to set-population-size to n (int):
		% Sets the population size to n and reinitializes the population.
		% The default value is 2000.
		populationSize = n.
		inited = 0.

	+ to get-population-size: 
		% Returns the population size.  See METHOD(set-population-size) for
		% more information.
		return populationSize.

	+ to set-crossover-percent to n (int):
		% Sets the percentage of agents generated by genetic crossover at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		crossoverPercent = n.

	+ to get-crossover-percent:
		% Returns the crossover percent.  See METHOD(set-crossover-percent)
		% for more information.
		return crossoverPercent.

	+ to set-mutation-percent to n (int):
		% Sets the percentage of agents generated by genetic mutation at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		mutationPercent = n.

	+ to get-mutation-percent:
		% Returns the mutation percent.  See METHOD(set-mutation-percent)
		% for more information.
		return mutationPercent.

	+ to set-deletion-percent to n (int):
		% Sets the percentage of agents generated by genetic deletion at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 5.
		deletionPercent = n.

	+ to get-deletion-percent:
		% Returns the deletion percent.  See METHOD(set-deletion-percent)
		% for more information.
		return deletionPercent.

	+ to read-interpreter-config from-file file (string):
		% Reads a configuration file for the interpreter used in the  
		% fitness tests.  Changing the configuration also reinitializes
		% the evolving population (since instructions sets may be changed).

		interpreter read-config from-file file.
		inited = 0.

	- to set-fitness-test-duration to d (double):
		% Sets the duration of the fitness test to d.  The duration of the 
		% fitness test determines how much simulation time is allowed for 
		% each fitness test.  
		% <P>
		% The default value is 0, a value which is appropriate for programs
		% which do not require simulation to determine fitness values.
		
		fitnessTestDuration = d.

	+ to set-spatial-radius to n (int):
		% Sets the spatial radius used for tournament selection during reproduction.  Setting
		% to 0 disables spatial effects.
		spatialRadius = n.

	- to get-fitness-test-duration:
		return fitnessTestDuration.

	+ to init:
		populationSize = 2000.
		mutationPercent = 40.
		deletionPercent = 5.
		crossoverPercent = 40.
		tournamentSize = 7.
		generationLimit = 300.

		_useChallenges = 0.

		interpreter = new PushInterpreter.

	- to create-population:
		n (int).

		if pop1: free pop1.
		if pop2: free pop2.

		pop1 = populationSize new PushGPIndividuals.
		pop2 = populationSize new PushGPIndividuals.

		pop1 set-interpreter to interpreter.
		pop2 set-interpreter to interpreter.

		current = pop1.
		next = pop2.

		if seed: (pop1{0} parse program seed).

		for n = 0, n < (self count-fitness-cases), n++: {
			push 0.0 onto _solutionCountsGeneration.
			push 0.0 onto _solutionCountsTotal.
			push 0.0 onto _solutionRatesGeneration.
			push 0.0 onto _solutionRatesTotal.
		}

		inited = 1.

	+ section "Getting the Push Interpreter Used During Evolution"

	+ to get-interpreter: 
		% Returns the OBJECT(PushInterpreter) object that this object is 
		% using for fitness tests.

		return interpreter.

	- to swap-current:
		% Used internally.
		if current == pop1: {
			current = pop2.
			next = pop1.
		} else {
			current = pop1.
			next = pop2.
		}

	+ to run-tournament for-index index = -1 (int):
		% Runs a tournament selection from the population.  Used internally during
		% reproduction uses the tournament size set with 
		% METHOD(set-tournament-size).
		% <P>
		% This method may be overridden to implement a custom tournament selection
		% if desired, though the default implementation should suffice in most 
		% situations.

		n, test (int).
		best (object).

		if spatialRadius == 0: best = current{ random[populationSize - 1] }.
		else {
			test = (index + (random[2 * spatialRadius - 1] - spatialRadius)).
			if test >= populationSize: test -= populationSize.
			if test < 0: test += populationSize.

			best = current{ test }.
		}

		for n = 0, n < tournamentSize - 1, n++: {
			if spatialRadius == 0: test = random[populationSize - 1].
			else {
				test = (index + (random[2 * spatialRadius - 1] - spatialRadius)).
				if test >= populationSize: test -= populationSize.
				if test < 0: test += populationSize.
			}

			if (current{test} get-fitness) < (best get-fitness): best = current{test}.
		}

		return best.

	+ to auto-simplify program p (object):
		% Programs generated through genetic programming are often complicated and 
		% difficult to understand.  This method attempts to simplify an evolved  
		% push program while maintaining the same fitness.
		% <P>
		% Each time this method is invoked, a random simplification is preformed 
		% on the program p.  If the simplification does not harm the fitness, p
		% is modified to contain the simplification, otherwise, nothing happens.
		% This method should be called repeatedly -- perhaps 100 times or more 
		% to aggressively simplify an unweildy program.

		fitness, newFitness (float).
		newProgram (object).

		fitness = (self compute-zero-duration-fitness for-program p).

		newProgram = new PushGPIndividual.

		newProgram copy-from program p.

		if random[1]: newProgram delete-random-subtree.
		else newProgram flatten-random-subtree.

		newFitness = (self compute-zero-duration-fitness for-program newProgram).	

		if newFitness == fitness: p copy-from program newProgram.

		free newProgram.

		return p.

	+ to compute-diversity for-tolerance t (int):
		% Computes the diversity of the current population, as defined by 
		% the OBJECT(PushDiversityPool) object.  Returns the number of 
		% unique "species" which differ by less than t points.

		pool (object).
		n (int).

		pool = new PushDiversityPool.
		pool set-tolerance to t.

		for n=0, n<|current|, n++: pool add program current{n}.

		n = (pool get-size).

		free pool.

		return n.

	+ to iterate:
		n (int).
		percent (int).

		if !inited: self create-population.

		for n=0,n<100,n++: self evaluate.

		percent = (100.0 * currentIndividual / populationSize).

		controller set-display-text to "Generation $generation: $percent% Complete" at-x -0.9 at-y -0.8.

		# if we're breeding in the next timestep, we'll set the message now...

		if currentIndividual >= (populationSize - 100): 
			controller set-display-text to "Generation $generation: breeding" at-x -0.9 at-y -0.8.

	+ to get-current-individual:
		% Returns the PushProgram currently being evaluated.
		if current && currentIndividual < | current |:
			return current{ currentIndividual }.
		
		return 0.

	- to evaluate:
		fitness (float).
		n (int).

		fitness = (self compute-zero-duration-fitness for-program current{ currentIndividual }).
		
		if fitness < 0.0: {
			# this indicates an error -- give it an arbitrarily bad fitness
			print "warning: error value lower than 0 for GP individual".
			fitness = 100000000.
		}

		if fitness < 0.001: {
			print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
			print ";; Solution found at generation $generation:", 
					(current{ currentIndividual }  get-string).

			self examine program current{ currentIndividual }.

			controller end-simulation.
		}

		if !_bestOfGen || (fitness < (_bestOfGen get-fitness)): _bestOfGen = current{ currentIndividual }.

		_totalSize += (current{ currentIndividual } get-size).
		_totalErrors += fitness.

		current{ currentIndividual } set-fitness to fitness.

		currentIndividual++.

		if currentIndividual == populationSize: {
			for n = 0, n < | _solutionCountsGeneration |, n++: {
				_solutionRatesGeneration{ n } = _solutionCountsGeneration{ n } / populationSize.
				_solutionRatesTotal{ n }      = _solutionCountsTotal{ n }     / ( populationSize * ( generation + 1 ) ).
			}

			self report with-best _bestOfGen.
			self reproduce.
			self swap-current.
			currentIndividual = 0.
			generation++.
			_bestOfGen = 0.
			_totalSize = 0.
			_totalErrors = 0.

			if generation > generationLimit: {
				print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
				print ";; FAILURE: no solution found after $generation generations".
				controller end-simulation.
			}
		}

	- to compute-zero-duration-fitness for-program p (object):
		n (int).
		errors (list).
		errorValue (float).

		_abortFitnessTest = 0.

		for n=0, n < (self count-fitness-cases), n++: {

			interpreter clear-stacks.

			self setup-fitness-test for-fitness-case n 
				with-interpreter interpreter.

			if (interpreter run program p): {
				errorValue = (self get-program-limit-penalty) + (self compute-error for-fitness-case n with-interpreter interpreter).
			} else {
				errorValue = (self compute-error for-fitness-case n with-interpreter interpreter).
			}

			if _useChallenges: {
				errorValue *= ( 1.1 - _solutionRatesGeneration{ n } ).
				# errorValue *= ( 1.1 - _solutionRatesTotal{ n } ).
				# print errorValue.
			}


			push errorValue onto errors.

			if _abortFitnessTest: {
				n = (self count-fitness-cases).
				return _abortFitnessValue.
			}

			if errors{ | errors | - 1 } == 0.0: {
				_solutionCountsGeneration{ n } += 1.0.
				_solutionCountsTotal{ n }      += 1.0.
			}
		}


		p set-errors to errors.

		return (self compute-error-vector-fitness for-errors errors).

	+ to get-program-limit-penalty:
		% Returns a penalty value applied to program which hit their evaluation limit.  The default value is .1, 
		% but you may override this method in order to penalize programs differently according to the problem.
		return .1.

	+ to abort-fitness-test with-fitness fitness = 99999999 (float):
		% Aborts the currently running fitness 
		_abortFitnessValue = fitness.
		_abortFitnessTest = 1.

	+ section "Methods Overridden by the User To Set Up PushGP Experiments"

	+ to examine program p (object):
		% This method is called when a solution is found.  You should override 
		% this method to preform any additional analysis you'd like.  Typically
		% this involves examining the program for generalization.
		% <P>
		% The default implementation simplifies the program p for 1000 iteration
		% using METHOD(auto-simplify) and prints out the result.
	
		n (int).

		for n=0,n<1000,n++: self auto-simplify program p.

		print ";; Simplifies to:", (current{ currentIndividual }  get-string).

	+ to compute-error-vector-fitness for-errors errorList (list):
		% This method takes a list of errors returned by METHOD(compute-error) for all 
		% fitness cases, and produces a fitness value.  The default implementation of 
		% this method computes the fitness by summing the absolute values of the errors,
		% which should suffice for most applications.
		% <P>
		% Overriding this method is optional.

		fitness, value (double).

		foreach value in errorList: fitness += | value |.

		return fitness.

	+ to setup-fitness-test for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to prepare to run 
		% the specified fitness test.  This typically means pushing input 
		% values onto the OBJECT(PushInterpreter) object's stacks.
		% <p>
		% In a symbolic regression problem, for example, this method might 
		% push a predetermined input value onto the float stack.
		% <pre>
		% 	interpreter push-float value inputValues{ n }.
		% </pre>

		die "The method setup-fitness-test must be overridden by the user -- see the class documentation for PushGPControl for more information".

	+ to count-fitness-cases:
		% This method must be overriden by the user in order to run a
		% PushGP experiment.  This method should return the number of 
		% fitness cases to be run.

		die "The method count-fitness-cases must be overridden by the user -- see the class documentation for PushGPControl for more information".
	
	+ to compute-error for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to inspect the 
		% state of the OBJECT(PushInterpreter) object and determine
		% the fitness (in terms of error) of the specified fitness case.  
		% This typically involves comparing values from the interpreter's 
		% stacks against desired values.
		% <p>
		% For example, with a symbolic regression problem, this method 
		% might return the difference between the top of the float stack, 
		% and the predetermined "correct" answer for the specified fitness 
		% case.  For example:
		% <pre>
		% 	return (interpreter get-float-stack-top) - desiredOutputs{ n }.
		% </pre>

		die "The method compute-error must be overridden by the user -- see the class documentation for PushGPControl for more information".

	+ to report with-best bestIndividual (object):
		% Logs information to the output at every generation.  This method 
		% may be overridden to provide more (or less) output data.  
		% <P>
		% The argument bestIndividual is the best individual in the population
		% and is provided so that it may be inspected by the user if this method
		% is overridden.

		bestFitness (float).
		errors (list).
		n (int).

		_totalSize /= populationSize.
		_totalErrors /= populationSize.

		bestFitness = (bestIndividual get-fitness).
		errors = (bestIndividual get-errors).

		print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
		print ";; -*- Report at generation $generation".
		print ";; Best Individual: ".
		print (bestIndividual get-string).
		print ";; Errors for best individual: ", errors.
		print ";; Problem solution rates this generation: ", _solutionRatesGeneration.
		print ";; Problem solution rates all generations: ", _solutionRatesTotal.
		print ";; Total errors for best individual: $bestFitness".
		print ";; Size of best individual (points):", (bestIndividual get-size).
		print ";;".
		print ";; Average total errors in population: $_totalErrors".
		print ";; Average program size in population (points): $_totalSize".
		print "".

		controller set-display-text to "Best Fitness: $bestFitness" at-x -0.9 at-y -0.9 number 2.

	+ to reproduce:
		% Used internally.                

		n, method (int).                
		p1, p2 (object).                

		for n = 0, n < (self count-fitness-cases), n++: {
			_solutionCountsGeneration{ n } = 0.0.
		}

		while n < populationSize: { 
			method = random[100]. 
			if method < mutationPercent: {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.
				next{n} mutate with-interpreter interpreter.
			} else if method < (crossoverPercent + mutationPercent): {
				p1 = (self run-tournament for-index n).
				p2 = (self run-tournament for-index n).
				next{n} crossover from-parent1 p1 from-parent2 p2 with-interpreter interpreter.     
			} else if method < (crossoverPercent + mutationPercent + deletionPercent): {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.
				next{n} delete-random-subtree.
			} else {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.

				# print "Copying from program with fitness ", ( p1 get-fitness ).
			}

			n++.
		}
}

PushProgram : PushGPIndividual (aka PushGPIndividuals) {
	% A class used by OBJECT(PushGP), this is a single individual
	% in a PushGP run.  It is not typically used directly by the user.

	+ variables:
		interpreter (object).
		fitness (double).
		errors (list).

	- to set-interpreter to newInterpreter (object):
		interpreter = newInterpreter.
		self make-random-code with-interpreter interpreter.

	- to set-errors to errorList (list):
		errors = errorList.

	+ to get-errors:
		% Returns the current list of errors for an individual as determined
		% by the fitness test.
		return errors.

	+ to set-fitness to newFitness (double):
		% Sets the fitness of this object to newFitness.  You 
		% shouldn't call this method unless you're implementing
		% your own GP system.

		fitness = newFitness.

	+ to get-fitness: 
		% Returns the fitness of this GP individual.

		return fitness.
}

@define PUSHGP_SERVER_PORT		59175.

PushGP : PushClusterGP {
	% PushClusterGP is a version of OBJECT(PushGP) that allows individual
	% programs in a genetic programming run to migrate to runs on other 
	% networked machines.  
	% <P>
	% Turning a single machine PushGP experiment to a multiple machine 
	% PushClusterGP experiment is simple.  Just provide a list of the 
	% hosts running the simulation to METHOD(set-emigration-hosts).
	% <P>
	% Note: using the PushClusterGP object will open a tcp server on 
	% port 59175.

	+ variables:
		emigrationHosts (list).
		emigrationPercent (float).
		transfer (object).
		server (object).
		lastTransfer (object).
		port (int).

	+ to init:
		server = new NetworkServer.
		server listen on-port PUSHGP_SERVER_PORT.
		server set-upload-recipient to self.
		emigrationPercent = 3.

		transfer = new PushProgramTransporter.

		port = PUSHGP_SERVER_PORT.

	- to accept-upload of immigrants (object) from h (string):
		free lastTransfer.
		lastTransfer = immigrants.

	+ to set-emigration-percent to n (int):
		% Sets the percentage of agents generated by genetic emigration at 
		% each generation.  This should be a value between 0 and 100, but 
		% should typically be relatively low: mutation and crossover should
		% be the primary genetic operators.
		% The default value is 3.

		emigrationPercent = n.

	+ to get-emigration-percent:
		% Returns the emigration percent.  See METHOD(set-emigration-percent)
		% for more information.

		return emigrationPercent.

	+ to set-emigration-hosts to hosts (list):
		% Sets the PushClusterGP object to send individual programs to 
		% hosts.

		emigrationHosts = copylist hosts.

	- to reproduce:
		% Used internally.                

		n, method (int).                
		p1, p2 (object).                

		recipientHost (string).

		index (int).

		while n < populationSize: { 
			method = random[100]. 
			if method < mutationPercent: {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.
				next{n} mutate with-interpreter interpreter.
			} else if method < (crossoverPercent + mutationPercent): {
				p1 = (self run-tournament for-index n).
				p2 = (self run-tournament for-index n).
				next{n} crossover from-parent1 p1 from-parent2 p2 with-interpreter interpreter.     
			} else if method < (crossoverPercent + mutationPercent + deletionPercent): {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.
				next{n} delete-random-subtree.
			} else if method < (crossoverPercent + mutationPercent + deletionPercent + emigrationPercent): {
				if lastTransfer: p1 = (lastTransfer get-random-program ).
				else p1 = (self run-tournament for-index n).

				next{n} copy-from program p1.
				index++.
			} else {
				p1 = (self run-tournament for-index n).
				next{n} copy-from program p1.
			}

			n++.
		}

		transfer clear.

		if | emigrationHosts | == 0: return.

		for n = 0, n < populationSize * (emigrationPercent / 100.0), n++: 
			transfer add program (self run-tournament).

		recipientHost = emigrationHosts{ random[ | emigrationHosts | - 1 ] }.
		transfer send-over-network to recipientHost on PUSHGP_SERVER_PORT.
}

Object : PushProgramTransporter {
	% Used by OBJECT(PushClusterGP) to send Push programs over the network.
	% No user-level methods are provided for this class.

	+ variables:
		programStrings (list).

	- to add program p (object):
		push (p get-string) onto programStrings.

	- to clear:
		programStrings = { }.

	- to parse-programs with-interpreter i (object):
		code (string).
		program (object).
		result (list).

		for each code in programStrings: {
			program = new PushProgram.
			program parse program code.
			push program onto result.
		}

		return result.

	- to get-program number n (int): 
		code (object).
		code = new PushProgram.

		if n >= | programStrings |: return code.
		code parse program programStrings{ n }.
		return code.

	- to get-random-program:
		return ( self get-program number random[ | programStrings | - 1 ] ).
}
